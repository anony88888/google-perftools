#! /usr/bin/perl -w

# Copyright (c) 2005, Google Inc.
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
# 
#     * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#     * Neither the name of Google Inc. nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# ---
# Program for printing the profile generated by common/profiler.cc,
# or by the heap profiler (common/debugallocation.cc)
#
# The profile contains a sequence of entries of the form:
#	<count> <stack trace>
# This program parses the profile, and generates user-readable
# output.
#
# Examples:
#
# % tools/pprof "program" "profile"
#   Generates one line per procedure
#
# % tools/pprof --gv "program" "profile"
#   Generates annotated call-graph and displays via "gv"
#
# % tools/pprof --gv --focus=Mutex "program" "profile"
#   Restrict to code paths that involve an entry that matches "Mutex"
#
# % tools/pprof --gv --focus=Mutex --ignore=string "program" "profile"
#   Restrict to code paths that involve an entry that matches "Mutex"
#   and does not match "string"
#
# % tools/pprof --list=IBF_CheckDocid "program" "profile"
#   Generates disassembly listing of all routines with at least one
#   sample that match the --list=<regexp> pattern.  The listing is
#   annotated with the flat and cumulative sample counts at each line.
#
# % tools/pprof --disasm=IBF_CheckDocid "program" "profile"
#   Generates disassembly listing of all routines with at least one
#   sample that match the --disasm=<regexp> pattern.  The listing is
#   annotated with the flat and cumulative sample counts at each PC value.
#
# TODO: Use color to indicate files?

use strict;
use Getopt::Long;

# These are the external binaries we use.  We hard-code in the path
# because some people have colorizing versions of these binaries which
# can cause trouble.
my $OBJDUMP = "/usr/bin/objdump";
my $NM = "/usr/bin/nm";
my $ADDR2LINE = "/usr/bin/addr2line";
my $DOT = "dot";          # leave non-absolute, since it may be in /usr/local

##### Argument parsing #####

sub usage_string {
  return <<'EOF';
Usage: pprof [options] <program> <profile>
   Prints specified cpu- or heap-profile 
   
Options:
   --cum               Sort by cumulative data
   --base=<base>       Subtract <base> from <profile> before display
   
Reporting Granularity:
   --addresses         Report at address level
   --lines             Report at source line level
   --functions         Report at function level [default]
   --files             Report at source file level
   
Output type:
   --text              Generate text report [default]
   --gv                Generate Postscript and display
   --list=<regexp>     Generate source listing of matching routines
   --disasm=<regexp>   Generate disassembly of matching routines
   --dot               Generate DOT file to stdout
   --ps                Generate Postcript to stdout
   --pdf               Generate PDF to stdout
   --gif               Generate GIF to stdout
   
Heap-Profile Options:
   --inuse_space       Display in-use (mega)bytes [default]
   --inuse_objects     Display in-use objects
   --alloc_space       Display allocated (mega)bytes
   --alloc_objects     Display allocated objects
   --show_bytes        Display space in bytes
   --drop_negative     Ignore negaive differences
   
Call-graph Options:
   --nodecount=<n>     Show at most so many nodes [default=80]
   --nodefraction=<f>  Hide nodes below <f>*total [default=.005]
   --edgefraction=<f>  Hide edges below <f>*total [default=.001]
   --focus=<regexp>    Focus on nodes matching <regexp>
   --ignore=<regexp>   Ignore nodes matching <regexp>
   --scale=<n>         Set GV scaling [default=0]
   
Examples:
   
pprof /bin/ls ls.prof
                       Outputs one line per procedure
pprof --gv /bin/ls ls.prof
                       Displays annotated call-graph via 'gv'
pprof --gv --focus=Mutex /bin/ls ls.prof
                       Restricts to code paths including a .*Mutex.* entry
pprof --gv --focus=Mutex --ignore=string /bin/ls ls.prof
                       Code paths including Mutex but not string
pprof --list=getdir /bin/ls ls.prof
                       (Per-line) annotated source listing for getdir()
pprof --disasm=getdir /bin/ls ls.prof
                       (Per-PC) annotated disassembly for getdir()
EOF
}

sub version_string {
  return <<'EOF'
pprof (part of google-perftools)

Copyright (c) 2005 Google Inc.
EOF
}

sub fatal {
  my $msg = shift;
  print STDERR "$msg\n\n";
  print STDERR usage_string();
  print STDERR "\nFATAL ERROR: $msg\n";    # just as a reminder
  exit(1);
}
  

$main::opt_help = 0;
$main::opt_version = 0;

$main::opt_cum = 0;
$main::opt_base = '';
$main::opt_addresses = 0;
$main::opt_lines = 0;
$main::opt_functions = 0;
$main::opt_files = 0;

$main::opt_text = 0;
$main::opt_list = "";
$main::opt_disasm = "";
$main::opt_gv = 0;
$main::opt_dot = 0;
$main::opt_ps = 0;
$main::opt_pdf = 0;
$main::opt_gif = 0;

$main::opt_nodecount = 80;
$main::opt_nodefraction = 0.005;
$main::opt_edgefraction = 0.001;
$main::opt_focus = '';
$main::opt_ignore = '';
$main::opt_scale = 0;

$main::opt_inuse_space   = 0;
$main::opt_inuse_objects = 0;
$main::opt_alloc_space   = 0;
$main::opt_alloc_objects = 0;
$main::opt_show_bytes    = 0;
$main::opt_drop_negative = 0;

# Are we printing a heap profile?
$main::heap_profile = 0;

GetOptions("help!"          => \$main::opt_help,
	   "version!"       => \$main::opt_version,
	   "cum!"           => \$main::opt_cum,
	   "base=s"         => \$main::opt_base,
	   "functions!"     => \$main::opt_functions,
	   "lines!"         => \$main::opt_lines,
	   "addresses!"     => \$main::opt_addresses,
	   "files!"         => \$main::opt_files,
	   "text!"          => \$main::opt_text,
	   "list=s"         => \$main::opt_list,
	   "disasm=s"       => \$main::opt_disasm,
	   "gv!"            => \$main::opt_gv,
	   "dot!"           => \$main::opt_dot,
	   "ps!"            => \$main::opt_ps,
	   "pdf!"           => \$main::opt_pdf,
	   "gif!"           => \$main::opt_gif,
	   "nodecount=i"    => \$main::opt_nodecount,
	   "nodefraction=f" => \$main::opt_nodefraction,
	   "edgefraction=f" => \$main::opt_edgefraction,
	   "focus=s"        => \$main::opt_focus,
	   "ignore=s"       => \$main::opt_ignore,
	   "scale=i"        => \$main::opt_scale,
	   "inuse_space!"   => \$main::opt_inuse_space,
	   "inuse_objects!" => \$main::opt_inuse_objects,
	   "alloc_space!"   => \$main::opt_alloc_space,
	   "alloc_objects!" => \$main::opt_alloc_objects,
	   "show_bytes!"    => \$main::opt_show_bytes,
	   "drop_negative!" => \$main::opt_drop_negative,
	   ) || fatal("Invalid option(s)");

# Deal with the standard --help and --version
if ($main::opt_help) {
  print usage_string();
  exit(0);
}

if ($main::opt_version) {
  print version_string();
  exit(0);
}

# Disassembly/listing mode requires address-level info
if ($main::opt_disasm || $main::opt_list) {
  $main::opt_functions = 0;
  $main::opt_lines = 0;
  $main::opt_addresses = 1;
  $main::opt_files = 0;
}

# Check heap-profiling flags
if ($main::opt_inuse_space +
    $main::opt_inuse_objects +
    $main::opt_alloc_space +
    $main::opt_alloc_objects > 1) {
  fatal("Specify at most on of --inuse/--alloc options");
}

# Check output granularities
my $grains =
  $main::opt_functions +
  $main::opt_lines +
  $main::opt_addresses +
  $main::opt_files +
  0;
if ($grains > 1) {
  fatal("Only specify one output granularity option");
}
if ($grains == 0) {
  $main::opt_functions = 1;
}

# Check output modes
my $modes =
  $main::opt_text +
  $main::opt_gv +
  $main::opt_dot +
  $main::opt_ps +
  $main::opt_pdf +
  $main::opt_gif +
  0;
if ($modes > 1) {
  fatal("Only specify one output mode");
}
if ($modes == 0) {
  $main::opt_text = 1;
}

my $prog = shift || fatal("Did not specify program");
my $pfile = shift || fatal("Did not specify profile file");

##### Main section #####

# Setup tmp-file name and handler to clean it up
$main::tmpfile_sym = "/tmp/pprof$$.sym";
$main::tmpfile_ps = "/tmp/pprof$$.ps";
$SIG{'INT'} = \&sighandler;

# Read profile data
my $data = ReadProfile($prog, $pfile);
my $profile = $data->{profile};
my $libs = $data->{libs};	# Info about main program and shared libraries

# List of function names to skip
$main::skip = ();
if ($main::heap_profile) {
  foreach my $name ('calloc',
		    'cfree',
		    'malloc',
		    'free',
		    'memalign',
		    'pvalloc',
		    'valloc',
		    'realloc',
		    '__builtin_delete',
		    '__builtin_new',
		    '__builtin_vec_delete',
		    '__builtin_vec_new') {
    $main::skip{$name} = 1;
  }
}

# Subtract base from profile, if specified
if ($main::opt_base ne '') {
  my $base = ReadProfile($prog, $main::opt_base)->{profile};
  $profile = SubtractProfile($profile, $base);
}

# Get total data in profile
my $total = TotalProfile($profile);

# Extract symbols
my $symbols = ExtractSymbols($libs, $profile, $data->{pcs});

# Focus?
if ($main::opt_focus ne '') {
  $profile = FocusProfile($symbols, $profile, $main::opt_focus);
}

# Ignore?
if ($main::opt_ignore ne '') {
  $profile = IgnoreProfile($symbols, $profile, $main::opt_ignore);
}

# Reduce profiles to required output granularity, and also clean
# each stack trace so a given entry exists at most once.
my $reduced = ReduceProfile($symbols, $profile);

# Get derived profiles
my $flat = FlatProfile($reduced);
my $cumulative = CumulativeProfile($reduced);

# Print
if ($main::opt_disasm) {
  PrintDisassembly($libs, $flat, $cumulative);
} elsif ($main::opt_list) {
  PrintListing($libs, $flat, $cumulative);
} elsif ($main::opt_text) {
  PrintText($symbols, $flat, $cumulative, $total);
} else {
  PrintDot($prog, $symbols, $profile, $flat, $cumulative, $total);
  if ($main::opt_gv) {
    system("gv -scale $main::opt_scale $main::tmpfile_ps");
  }
}

cleanup();
exit(0);

##### Output code #####

# Print text output
sub PrintText {
  my $symbols = shift;
  my $flat = shift;
  my $cumulative = shift;
  my $total = shift;

  # Which profile to sort by?
  my $s = $main::opt_cum ? $cumulative : $flat;

  my $running_sum = 0;
  foreach my $k (sort { GetEntry($s,$b) <=> GetEntry($s, $a) }
		 keys(%{$cumulative})) {
    my $f = GetEntry($flat, $k);
    my $c = GetEntry($cumulative, $k);
    $running_sum += $f;

    my $sym = $k;
    if (exists($symbols->{$k})) {
      $sym = $symbols->{$k}->[0] . " " . $symbols->{$k}->[1];
      if ($main::opt_addresses) {
	$sym = $k . " " . $sym;
      }
    }

    if ($f != 0 || $c != 0) {
      printf("%8s %6s %6s %8s %6s %s\n",
             Unparse($f),
             Percent($f, $total),
             Percent($running_sum, $total),
             Unparse($c),
             Percent($c, $total),
             $sym);
    }
  }
}

# Print disassembly for all all routines that match $main::opt_disasm
sub PrintDisassembly {
  my $libs = shift;
  my $flat = shift;
  my $cumulative = shift;

  foreach my $lib (@{$libs}) {
    my $symbol_table = GetProcedureBoundaries($lib->[0], $main::opt_disasm);
    my $offset = $lib->[1] - $lib->[3];
    foreach my $routine (keys(%{$symbol_table})) {
      my $start_addr = $symbol_table->{$routine}->[0];
      my $end_addr = $symbol_table->{$routine}->[1];
      # See if there are any samples in this routine
      my $total_flat = 0;
      my $total_cum = 0;
      for (my $addr = $start_addr; $addr < $end_addr; $addr++) {
	$total_flat += GetEntry($flat, sprintf("0x%x", $addr+$offset));
	$total_cum += GetEntry($cumulative, sprintf("0x%x", $addr+$offset));
      }

      # Skip disassembly if there are no samples in routine
      next if ($total_cum == 0);

      print "ROUTINE ====================== $routine\n";
      printf "%6s %6s Total samples (flat / cumulative)\n",
	Unparse($total_flat), Unparse($total_cum);

      my @instructions = Disassemble($lib->[0], $offset,
				     $start_addr, $end_addr);
      foreach my $e (@instructions) {
	my $location = ($e->[2] >= 0) ? "$e->[1]:$e->[2]" : "";
	$location =~ s|.*/||;	# Remove directory portion, if any
	if (length($location) >= 20) {
	  # For long locations, just show the last 20 characters
	  $location = substr($location, -20);
	}
	my $f = GetEntry($flat, $e->[0]);
	my $c = GetEntry($cumulative, $e->[0]);
	my $address = $e->[0];	$address =~ s/^0x//;
	printf("%6s %6s %-20s %8s: %6s\n",
	       UnparseAlt($f),
	       UnparseAlt($c),
	       $location,
	       $address,
	       $e->[3]);
      }
      close(OBJDUMP);
    }
  }
}

# Return reference to array of tuples of the form:
#	[address, filename, linenumber, instruction]
# E.g.,
#	["0x806c43d", "/foo/bar.cc", 131, "ret"]
sub Disassemble {
  my $prog = shift;
  my $offset = shift;
  my $start_addr = shift;
  my $end_addr = shift;

  my $cmd = sprintf("$OBJDUMP -d -l --no-show-raw-insn " .
		    "--start-address=%d --stop-address=%d $prog",
		    $start_addr, $end_addr);
  open(OBJDUMP, "$cmd |") || error("$OBJDUMP: $!\n");
  my @result = ();
  my $filename = "";
  my $linenumber = -1;
  while (<OBJDUMP>) {
    chop;
    if (m|\s*([^:\s]+):(\d+)\s*$|) {
      # Location line of the form:
      #   <filename>:<linenumber>
      $filename = $1;
      $linenumber = $2;
    } elsif (m/^ +([0-9a-f]+):\s*(.*)/) {
      # Disassembly line
      my $k = sprintf("0x%x", hex($1) + $offset);
      push(@result, [$k, $filename, $linenumber, $2]);
    }
  }
  close(OBJDUMP);
  return @result;
}

# For sorting functions by name
sub ByName {
  return ShortFunctionName($a) cmp ShortFunctionName($b);
}

# Print source-listing for all all routines that match $main::opt_list
sub PrintListing {
  my $libs = shift;
  my $flat = shift;
  my $cumulative = shift;

  foreach my $lib (@{$libs}) {
    my $symbol_table = GetProcedureBoundaries($lib->[0], $main::opt_list);
    my $offset = $lib->[1] - $lib->[3];
    foreach my $routine (sort ByName keys(%{$symbol_table})) {
      # Print if there are any samples in this routine
      my $start_addr = $symbol_table->{$routine}->[0];
      my $end_addr = $symbol_table->{$routine}->[1];
      for (my $addr = $start_addr; $addr < $end_addr; $addr++) {
	if (defined($cumulative->{sprintf("0x%x", $addr+$offset)})) {
	  PrintSource($lib->[0], $offset,
		      $routine, $flat, $cumulative,
		      $start_addr, $end_addr);
	  last;
	}
      }
    }
  }
}

# Print source-listing for one routine
sub PrintSource {
  my $prog = shift;
  my $offset = shift;
  my $routine = shift;
  my $flat = shift;
  my $cumulative = shift;
  my $start_addr = shift;
  my $end_addr = shift;

  # Disassemble all instructions (just to get line numbers)
  my @instructions = Disassemble($prog, $offset, $start_addr, $end_addr);

  # Hack 1: assume that the last source location mentioned in the
  # disassembly is the end of the source code.
  my $filename = undef;
  my $lastline = -1;
  for (my $i = $#instructions; $i >= 0; $i--) {
    if ($instructions[$i]->[2] >= 0) {
      $filename = $instructions[$i]->[1];
      $lastline = $instructions[$i]->[2];
      last;
    }
  }
  if (!defined($filename)) {
    print STDERR "no filename found in $routine\n";
    return;
  }

  # Hack 2: assume the first source location from "filename" is the start of
  # the source code.
  my $firstline = 1;
  for (my $i = 0; $i <= $#instructions; $i++) {
    if ($instructions[$i]->[1] eq $filename) {
      $firstline = $instructions[$i]->[2];
      last;
    }
  }

  # Assign all samples to the range $firstline,$lastline,
  # Hack 3: If an instruction does not occur in the range, its samples
  # are moved to the next instruction that occurs in the range.
  my $samples1 = {};
  my $samples2 = {};
  my $running1 = 0;	# Unassigned flat counts
  my $running2 = 0;	# Unassigned cumulative counts
  my $total1 = 0;	# Total flat counts
  my $total2 = 0;	# Total cumulative counts
  foreach my $e (@instructions) {
    my $c1 = GetEntry($flat, $e->[0]);
    my $c2 = GetEntry($cumulative, $e->[0]);
    $running1 += $c1;
    $running2 += $c2;
    $total1 += $c1;
    $total2 += $c2;
    my $file = $e->[1];
    my $line = $e->[2];
    if (($file eq $filename) &&
        ($line >= $firstline) &&
        ($line <= $lastline)) {
      # Assign all accumulated samples to this line
      AddEntry($samples1, $line, $running1);
      AddEntry($samples2, $line, $running2);
      $running1 = 0;
      $running2 = 0;
    }
  }

  # Assign any leftover samples to $lastline
  AddEntry($samples1, $lastline, $running1);
  AddEntry($samples2, $lastline, $running2);

  printf("ROUTINE ====================== %s in %s\n" .
	 "%6s %6s Total %s (flat / cumulative)\n",
	 ShortFunctionName($routine),
	 $filename,
	 Units(),
	 Unparse($total1),
	 Unparse($total2));
  if (!open(FILE, "<$filename")) {
    print STDERR "$filename: $!\n";
    return;
  }
  my $l = 0;
  while (<FILE>) {
    $l++;
    if ($l >= $firstline - 5 && $l <= $lastline + 5) {
      chop;
      my $text = $_;
      printf("%6s %6s %4d: %s\n",
	     UnparseAlt(GetEntry($samples1, $l)),
	     UnparseAlt(GetEntry($samples2, $l)),
	     $l,
	     $text);
    };
  }
  close(FILE);
}

# Print DOT graph
sub PrintDot {
  my $prog = shift;
  my $symbols = shift;
  my $raw = shift;
  my $flat = shift;
  my $cumulative = shift;
  my $overall_total = shift;

  # Get total
  my $local_total = TotalProfile($flat);
  my $nodelimit = int($main::opt_nodefraction * $local_total);
  my $edgelimit = int($main::opt_edgefraction * $local_total);
  my $nodecount = $main::opt_nodecount;

  # Find nodes to include
  my @list = (sort { abs(GetEntry($cumulative, $b)) <=>
                     abs(GetEntry($cumulative, $a)) }
	      keys(%{$cumulative}));
  my $last = $nodecount - 1;
  if ($last > $#list) {
    $last = $#list;
  }
  while (($last >= 0) &&
         (abs(GetEntry($cumulative, $list[$last])) <= $nodelimit)) {
    $last--;
  }
  if ($last < 0) {
    print STDERR "No nodes to print\n";
    exit(1);
  }

  printf STDERR ("Dropping nodes with <= %s %s; edges with <= %s abs(%s)\n",
		 Unparse($nodelimit), Units(),
		 Unparse($edgelimit), Units());

  # Open DOT output file
  my $output;
  if ($main::opt_gv) {
    $output = "| $DOT -Tps >$main::tmpfile_ps";
  } elsif ($main::opt_ps) {
    $output = "| $DOT -Tps";
  } elsif ($main::opt_pdf) {
    $output = "| $DOT -Tps | ps2pdf - -";
  } elsif ($main::opt_gif) {
    $output = "| $DOT -Tgif";
  } else {
    $output = ">&STDOUT";
  }
  open(DOT, $output) || error("$output: $!\n");

  # Title
  printf DOT ("digraph \"%s; %s %s\" {\n",
	      $prog,
	      Unparse($overall_total),
	      Units());
  if ($main::opt_pdf) {
    # The output is more printable if we set the page size for dot. 
    printf DOT ("size=\"8,11\"\n");
  }   
  printf DOT ("node [width=0.375,height=0.25];\n");

  # Print legend
  printf DOT ("Legend [shape=box,fontsize=24,shape=plaintext," .
	      "label=\"%s\\l%s\\l%s\\l%s\\l%s\\l\"];\n",
	      $prog,
	      sprintf("Total %s: %s", Units(), Unparse($overall_total)),
	      sprintf("Focusing on: %s", Unparse($local_total)),
	      sprintf("Dropped nodes with <= %s abs(%s)",
		      Unparse($nodelimit), Units()),
	      sprintf("Dropped edges with <= %s %s",
		      Unparse($edgelimit), Units())
	      );

  # Print nodes
  my %node = ();
  my $nextnode = 1;
  foreach my $a (@list[0..$last]) {
    # Pick font size
    my $f = GetEntry($flat, $a);
    my $c = GetEntry($cumulative, $a);

    my $fs = 8;
    if ($local_total > 0) {
      $fs = 8 + (50.0 * sqrt(abs($f * 1.0 / $local_total)));
    }

    $node{$a} = $nextnode++;
    my $sym = $a;
    $sym =~ s/\s+/\\n/g;
    $sym =~ s/::/\\n/g;

    # Extra cumulative info to print for non-leaves
    my $extra = "";
    if ($f != $c) {
      $extra = sprintf("\\rof %s (%s)",
                       Unparse($c),
                       Percent($c, $overall_total));
    }
    printf DOT ("N%d [label=\"%s\\n%s (%s)%s\\r" .
                "\",shape=box,fontsize=%.1f];\n",
                $node{$a},
                $sym,
                Unparse($f),
                Percent($f, $overall_total),
                $extra,
                $fs,
               );
  }

  # Get edges and counts per edge
  my %edge = ();
  foreach my $k (keys(%{$raw})) {
    # TODO: omit low %age edges
    my $n = $raw->{$k};
    my @addrs = split(/\n/, $k);
    for (my $i = 1; $i <= $#addrs; $i++) {
      my $src = OutputKey($symbols, $addrs[$i]);
      my $dst = OutputKey($symbols, $addrs[$i-1]);
      #next if ($src eq $dst);	# Avoid self-edges?
      if (exists($node{$src}) && exists($node{$dst})) {
	my $e = "$src\001$dst";
	if (!exists($edge{$e})) {
	  $edge{$e} = 0;
	}
	$edge{$e} += $n;
      }
    }
  }

  # Print edges
  foreach my $e (keys(%edge)) {
    my @x = split(/\001/, $e);
    my $n = $edge{$e};

    if (abs($n) > $edgelimit) {
      # Compute line width based on edge count
      my $fraction = $local_total ? (3 * ($n / $local_total)) : 0;
      if ($fraction > 1) { $fraction = 1; }
      my $w = $fraction * 2;
      #if ($w < 1) { $w = 1; }

      # Use a slightly squashed function of the edge count as the weight
      printf DOT ("N%s -> N%s [label=%s, weight=%d, " .
		  "style=\"setlinewidth(%f)\"];\n", 
		  $node{$x[0]},
		  $node{$x[1]},
		  Unparse($n),
		  int($n ** 0.7),
		  $w);
    }
  }

  print DOT ("}\n");

  close(DOT);
}

# Generate the key under which a given address should be counted
# based on the user-specified output granularity.
sub OutputKey {
  my $symbols = shift;
  my $a = shift;

  # Skip large addresses since they sometimes show up as fake entries on RH9
  if (hex($a) > 0x7fffffff) {
    return '';
  }

  # Extract symbolic info for address
  my $func = $a;
  my $fullfunc = $a;
  my $fileline = "";
  if (exists($symbols->{$a})) {
    $func = $symbols->{$a}->[0];
    $fullfunc = $symbols->{$a}->[2];
    $fileline = $symbols->{$a}->[1];
  }

  # We drop a few well-known names
  if ($main::skip{$func}) {
    return '';
  }

  if ($main::opt_disasm || $main::opt_list) {
    return $a;   # We want just the address for the key
  } elsif ($main::opt_addresses) {
    return "$a $func $fileline";
  } elsif ($main::opt_lines) {
    return "$func $fileline";
  } elsif ($main::opt_functions) {
    return $func;
  } elsif ($main::opt_files) {
    my $f = ($fileline eq '') ? $a : $fileline;
    $f =~ s/:\d+$//;
    return $f;
  } else {
    return $a;
  }
}

# Generate percent string for a number and a total
sub Percent {
  my $num = shift;
  my $tot = shift;
  if ($tot != 0) {
    return sprintf("%.1f%%", $num * 100.0 / $tot);
  } else {
    return ($num == 0) ? "nan" : (($num > 0) ? "+inf" : "-inf");
  }
}

# Generate pretty-printed form of number
sub Unparse {
  my $num = shift;
  if ($main::heap_profile) {
    if ($main::opt_inuse_objects || $main::opt_alloc_objects) {
      return sprintf("%d", $num);
    } else {
      if ($main::opt_show_bytes) {
        return sprintf("%d", $num);
      } else {
        return sprintf("%.1f", $num / 1048576.0);
      }
    }
  } else {
    return sprintf("%d", $num);
  }
}

# Alternate pretty-printed form: 0 maps to "."
sub UnparseAlt {
  my $num = shift;
  if ($num == 0) {
    return ".";
  } else {
    return Unparse($num);
  }
}

# Return output units
sub Units {
  if ($main::heap_profile) {
    if ($main::opt_inuse_objects || $main::opt_alloc_objects) {
      return "objects";
    } else {
      if ($main::opt_show_bytes) {
        return "B";
      } else {
        return "MB";
      }
    }
  } else {
    return "samples";
  }
}

##### Profile manipulation code #####

# Generate flattened profile:
# If count is charged to stack [a,b,c,d], in generated profile,
# it will be charged to [a]
sub FlatProfile {
  my $profile = shift;
  my $result = {};
  foreach my $k (keys(%{$profile})) {
    my $count = $profile->{$k};
    my @addrs = split(/\n/, $k);
    AddEntry($result, $addrs[0], $count);
  }
  return $result;
}

# Generate cumulative profile:
# If count is charged to stack [a,b,c,d], in generated profile,
# it will be charged to [a], [b], [c], [d]
sub CumulativeProfile {
  my $profile = shift;
  my $result = {};
  foreach my $k (keys(%{$profile})) {
    my $count = $profile->{$k};
    my @addrs = split(/\n/, $k);
    foreach my $a (@addrs) {
      AddEntry($result, $a, $count);
    }
  }
  return $result;
}

# Reduce profile to granularity given by user
sub ReduceProfile {
  my $symbols = shift;
  my $profile = shift;
  my $result = {};
  foreach my $k (keys(%{$profile})) {
    my $count = $profile->{$k};
    my @addrs = split(/\n/, $k);
    my @path = ();
    my %seen = ();
    $seen{''} = 1;	# So that empty keys are skipped
    foreach my $a (@addrs) {
      # To avoid double-counting due to recursion, skip a stack-trace
      # entry if it has already been seen
      my $key = OutputKey($symbols, $a);
      if (!$seen{$key}) {
	$seen{$key} = 1;
	push(@path, $key);
      }
    }
    my $reduced_path = join("\n", @path);
    AddEntry($result, $reduced_path, $count);
  }
  return $result;
}

# Focus only on paths involving specified regexps
sub FocusProfile {
  my $symbols = shift;
  my $profile = shift;
  my $focus = shift;
  my $result = {};
  foreach my $k (keys(%{$profile})) {
    my $count = $profile->{$k};
    my @addrs = split(/\n/, $k);
    foreach my $a (@addrs) {
      # Reply if it matches either the address/shortname/fileline
      if (($a =~ m/$focus/o) ||
	  (exists($symbols->{$a}) &&
	   (($symbols->{$a}->[0] =~ m/$focus/o) ||
	    ($symbols->{$a}->[1] =~ m/$focus/o)))) {
	AddEntry($result, $k, $count);
	last;
      }
    }
  }
  return $result;
}

# Focus only on paths not involving specified regexps
sub IgnoreProfile {
  my $symbols = shift;
  my $profile = shift;
  my $ignore = shift;
  my $result = {};
  foreach my $k (keys(%{$profile})) {
    my $count = $profile->{$k};
    my @addrs = split(/\n/, $k);
    my $matched = 0;
    foreach my $a (@addrs) {
      # Reply if it matches either the address/shortname/fileline
      if (($a =~ m/$ignore/o) ||
	  (exists($symbols->{$a}) &&
	   (($symbols->{$a}->[0] =~ m/$ignore/o) ||
	    ($symbols->{$a}->[1] =~ m/$ignore/o)))) {
	$matched = 1;
	last;
      }
    }
    if (!$matched) {
      AddEntry($result, $k, $count);
    }
  }
  return $result;
}

# Get total count in profile
sub TotalProfile {
  my $profile = shift;
  my $result = 0;
  foreach my $k (keys(%{$profile})) {
    $result += $profile->{$k};
  }
  return $result;
}

# Subtract B from A
sub SubtractProfile {
  my $A = shift;
  my $B = shift;

  my $R = {};
  foreach my $k (keys(%{$A})) {
    my $v = $A->{$k} - GetEntry($B, $k);
    if ($v < 0 && $main::opt_drop_negative) {
      $v = 0;
    }
    AddEntry($R, $k, $v);
  }
  if (!$main::opt_drop_negative) {
    # take care of when substracted profile has more things
    foreach my $k (keys(%{$B})) {
      if (!exists($A->{$k})) {
        AddEntry($R, $k, 0 - $B->{$k});
      }
    }
  }
  return $R;
}

# Get entry from profile; zero if not present
sub GetEntry {
  my $profile = shift;
  my $k = shift;
  if (exists($profile->{$k})) {
    return $profile->{$k};
  } else {
    return 0;
  }
}

# Add entry to specified profile
sub AddEntry {
  my $profile = shift;
  my $k = shift;
  my $n = shift;
  if (!exists($profile->{$k})) {
    $profile->{$k} = 0;
  }
  $profile->{$k} += $n;
}

##### Parsing code #####

# Parse profile generated by common/profiler.cc and return a reference
# to a map:
#      $result->{version}     Version number of profile file
#      $result->{period}      Sampling period (in microseconds)
#      $result->{profile}     Profile object
#      $result->{map}         Memory map info from profile
#      $result->{pcs}         List of all PC values seen
sub ReadProfile {
  my $prog = shift;
  my $fname = shift;

  # Look at first line to see if it is a heap or a CPU profile
  open(PROFILE, "<$fname") || error("$fname: $!\n");
  binmode PROFILE;	# New perls do UTF-8 processing
  my $header = <PROFILE>;
  if ($header =~ m/^heap profile:/) {
    $main::heap_profile = 1;
    return ReadHeapProfile($prog, $fname);
  } else {
    # Need to unread the line we just read
    close(PROFILE);
    open(PROFILE, "<$fname") || error("$fname: $!\n");
    binmode PROFILE;	# New perls do UTF-8 processing
    $main::heap_profile = 0;
    return ReadCPUProfile($prog, $fname);
  }
}

# CPU profile reader
sub ReadCPUProfile {
  my $prog = shift;
  my $fname = shift;

  # Read entire profile into a string
  my $str;
  my $nbytes = read(PROFILE, $str, 100000000);
  close(PROFILE);

  # Parse string into array of slots.
  # L! is needed for 64-bit # platforms, but not supported on 5.005
  # (despite the manpage claims)

  my $format;
  if ($] >= 5.008) {
      $format = "L!*";
  } else {
      $format = "L*";
  }

  my @slots = unpack($format, $str);

  # Read header
  if ($#slots < 1 || $slots[0] != 0 || $slots[1] < 3) {
    error("$fname: not a profile file, or old format profile file\n");
  }
  my $version = $slots[2];
  my $period = $slots[3];
  my $i = 2 + $slots[1];

  # Parse profile
  my $profile = {};
  my $pcs = {};
  while ($i <= $#slots) {
    my $n = $slots[$i++];
    my $d = $slots[$i++];
    if ($slots[$i] == 0) {
      # End of profile data marker
      $i += $d;
      last;
    }

    # Make key out of the stack entries
    my $k = "";
    for (my $j = 0; $j < $d; $j++) {
      my $pc = $slots[$i+$j];
      $pcs->{$pc} = 1;
      $k .= sprintf("\n0x%x", $pc);
    }
    $k =~ s/^\n//;

    AddEntry($profile, $k, $n);
    $i += $d;
  }

  # Parse map
  my $map = substr($str, $i * 4);

  my $r = {};
  $r->{version} = $version;
  $r->{period} = $period;
  $r->{profile} = $profile;
  $r->{libs} = ParseLibraries($prog, $map, $pcs);
  $r->{pcs} = $pcs;

  return $r;
}

sub ReadHeapProfile {
  my $prog = shift;
  my $fname = shift;

  my $index = 1;
  if ($main::opt_inuse_space) {
    $index = 1;
  } elsif ($main::opt_inuse_objects) {
    $index = 0;
  } elsif ($main::opt_alloc_space) {
    $index = 3;
  } elsif ($main::opt_alloc_objects) {
    $index = 2;
  }

  my $profile = {};
  my $pcs = {};
  my $map = "";
  while (<PROFILE>) {
    if (/^MAPPED_LIBRARIES:/) {
      # Read the /proc/self/maps data
      while (<PROFILE>) {
	$map .= $_;
      }
      last;
    }

    if (/^--- Memory map:/) {
      # Read /proc/self/maps data as formatted by DumpAddressMap()
      while (<PROFILE>) {
	$map .= $_;
      }
      last;
    }

    # Read entry of the form:
    #  <count1>: <bytes1> [<count2>: <bytes2>] @ a1 a2 a3 ... an
    s/^\s*//;
    s/\s*$//;
    if (m/^\s*(\d+):\s+(\d+)\s+\[\s*(\d+):\s+(\d+)\]\s+@\s+(.*)$/) {
      my $stack = $5;
      my @counts = ($1, $2, $3, $4);
      my $n = $counts[$index];
      my $k = "";
      foreach my $e (split(/\s+/, $stack)) {
        my $pc = hex($e);
        $pcs->{$pc} = 1;
        $k .= sprintf("\n0x%x", $pc);
      }
      $k =~ s/^\n//;
      AddEntry($profile, $k, $n);
    }
  }

  my $r = {};
  $r->{version} = "heap";
  $r->{period} = 1;
  $r->{profile} = $profile;
  $r->{libs} = ParseLibraries($prog, $map, $pcs);
  $r->{pcs} = $pcs;
  return $r;
}

##### Symbol extraction #####

# Split /proc/pid/maps dump into a list of libraries
sub ParseLibraries {
  my $prog = shift;
  my $map = shift;
  my $pcs = shift;

  my $result = [];
  my $h = "[a-f0-9]+";
  foreach my $l (split("\n", $map)) {
    my $start;
    my $finish;
    my $offset;
    my $lib;
    if ($l =~ /^($h)-($h)\s+..x.\s+($h)\s+\S+:\S+\s+\d+\s+(\S+\.so(\.\d+)*)/) {
      # Full line from /proc/self/maps.  Example:
      #   40000000-40015000 r-xp 00000000 03:01 12845071   /lib/ld-2.3.2.so
      $start = hex($1);
      $finish = hex($2);
      $offset = hex($3);
      $lib = $4;
    } elsif ($l =~ /^\s*($h)-($h):\s*(\S+\.so(\.\d+)*)/) {
      # Cooked line from DumpAddressMap.  Example:
      #	  40000000-40015000: /lib/ld-2.3.2.so
      $start = hex($1);
      $finish = hex($2);
      $offset = 0;
      $lib = $3;
    } else {
      next;
    }

    # Get objdump output from the library file to figure out how to
    # map between mapped addresses and addresses in the library.
    open(OBJDUMP, "$OBJDUMP -h $lib |") || error("$OBJDUMP $lib: $!\n");
    while (<OBJDUMP>) {
      # Idx Name          Size      VMA       LMA       File off  Algn
      #  10 .text         00104b2c  420156f0  420156f0  000156f0  2**4
      my @x = split;
      if (($#x >= 6) && ($x[1] eq '.text')) {
	my $vma = hex($x[3]);
	my $file_offset = hex($x[5]);
	$offset += $vma - $file_offset;
	last;
      }
    }
    close(OBJDUMP);

    push(@{$result}, [$lib, $start, $finish, $offset]);
  }

  # Append special entry for the main program
  my $max_pc = 0;
  foreach my $pc (keys(%{$pcs})) {
    if ($pc > $max_pc) { $max_pc = $pc; }
  }
  push(@{$result}, [$prog, 0, $max_pc, 0]);

  return $result;
}

# Extract symbols for all PC values found in profile
sub ExtractSymbols {
  my $libs = shift;
  my $profile = shift;
  my $pcset = shift;

  my $symbols = {};

  # Map each PC value to the containing library
  my %seen = ();
  foreach my $lib (@{$libs}) {
    my $libname = $lib->[0];
    my $start = $lib->[1];
    my $finish = $lib->[2];
    my $offset = $lib->[3];

    # Get list of pcs that belong in this library.
    my $contained = [];
    foreach my $pc (keys(%{$pcset})) {
      if (!$seen{$pc} && ($pc >= $start) && ($pc <= $finish)) {
	$seen{$pc} = 1;
	push(@{$contained}, $pc);
      }
    }
    # Map to symbols
    MapToSymbols($libname, $start - $offset, $contained, $symbols);
  }

  return $symbols;
}

# Map list of PC values to symbols for a given image
sub MapToSymbols {
  my $image = shift;
  my $offset = shift;
  my $pclist = shift;
  my $symbols = shift;

  # Ignore empty binaries
  if ($#{$pclist} < 0) { return; }

  MapSymbolsWithNM($image, $offset, $pclist, $symbols);
  if ($main::opt_lines || $main::opt_files || $main::opt_list) {
    GetLineNumbers($image, $offset, $pclist, $symbols);
  }
}

sub GetLineNumbers {
  my $image = shift;
  my $offset = shift;
  my $pclist = shift;
  my $symbols = shift;

  # Make file with all PC values
  open(ADDRESSES, ">$main::tmpfile_sym") || error("$main::tmpfile_sym: $!\n");
  for (my $i = 0; $i <= $#{$pclist}; $i++) {
    printf ADDRESSES ("0x%x\n", $pclist->[$i] - $offset);
  }
  close(ADDRESSES);

  # Pass to addr2line
  open(SYMBOLS, "$ADDR2LINE -f -C -e $image <$main::tmpfile_sym |")
    || error("$ADDR2LINE: $!\n");
  my $count = 0;
  while (<SYMBOLS>) {
    chop;
    my $fullfunction = $_;

    $_ = <SYMBOLS>;
    chop;
    my $filelinenum = $_;
    if (!$main::opt_list) {
      $filelinenum =~ s|^.*/([^/]+:\d+)$|$1|;    # Remove directory name
    }

    my $pcstr = sprintf("0x%x", $pclist->[$count]);
    if (defined($symbols->{$pcstr})) {
      # Override just the line-number portion.  The function name portion
      # is less buggy when computed using nm instead of addr2line.
      $symbols->{$pcstr}->[1] = $filelinenum;
    } else {
      my $function = ShortFunctionName($fullfunction);
      $symbols->{$pcstr} = [$function, $filelinenum, $fullfunction];
    }
    $count++;
  }
  close(SYMBOLS);
}

# Alternate implementation
sub MapSymbolsWithNM {
  my $image = shift;
  my $offset = shift;
  my $pclist = shift;
  my $symbols = shift;

  # Get nm output sorted by increasing address
  my $symbol_table = GetProcedureBoundaries($image, ".");
  my @names = sort { $symbol_table->{$a}->[0] <=> $symbol_table->{$b}->[0] }
    keys(%{$symbol_table});

  if ($#names < 0) {
    # No symbols: just use address
    foreach my $pc (@{$pclist}) {
      my $pcstr = sprintf("0x%x", $pc);
      $symbols->{$pcstr} = [$pcstr, "?", $pcstr];
    }
    return;
  }

  # Sort addresses so we can do a join against nm output
  my $index = 0;
  my $fullname = $names[0];
  my $name = ShortFunctionName($fullname);
  foreach my $pc (sort { $a <=> $b } @{$pclist}) {
    # Adjust for mapped offset
    my $mpc = $pc - $offset;
    while (($index < $#names) && ($mpc >= $symbol_table->{$fullname}->[1])){
      $index++;
      $fullname = $names[$index];
      $name = ShortFunctionName($fullname);
    }
    my $pcstr = sprintf("0x%x", $pc);
    $symbols->{$pcstr} = [$name, "?", $fullname];
  }
}

sub ShortFunctionName {
  my $function = shift;
  while ($function =~ s/\([^()]*\)//g) { }   # Remove argument types
  while ($function =~ s/<[^<>]*>//g)  { }    # Remove template arguments
  $function =~ s/^.*\s+(\w+::)/$1/;	     # Remove leading type
  return $function;
}

##### Miscellaneous #####

sub cleanup {
  unlink($main::tmpfile_sym);
  unlink($main::tmpfile_ps);
}

sub sighandler {
  cleanup();
  exit(1);
}

sub error {
  my $msg = shift;
  print STDERR $msg;
  cleanup();
  exit(1);
}

# Return a list of all routines that match $regexp.
# For each routine, the following list is returned:
#	$result->[i]->[0]	Routine name
#	$result->[i]->[1]	Start address
#	$result->[i]->[2]	Finish address
#	$result->[i]->[3]	Image file name (program or shared library)
#	$result->[i]->[4]	Offset for image in address space
sub GetMatchingRoutines {
}


# Gets the procedure boundaries for all routines in "$image" whose names
# match "$regexp" and returns them in a hashtable mapping from procedure
# name to a two-element vector of [start address, end address]
sub GetProcedureBoundaries {
  my $image = shift;
  my $regexp = shift;

  my $symbol_table = {};
  open(NM, "$NM -C -n $image |") || error("$NM: $!\n");
  my $last_start = "0x0";
  my $routine = "";
  while (<NM>) {
    if (m/^([0-9a-f]+) . (..*)/) {
      my $start_val = $1;
      my $this_routine = $2;
      if (defined($routine) && $routine =~ m/$regexp/) {
	$symbol_table->{$routine} = [hex($last_start), hex($start_val)];
      }
      $last_start = $start_val;
      $routine = $this_routine;
    }
  }
  close(NM);

  return $symbol_table;
}
