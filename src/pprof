#! /usr/bin/perl -w

# Copyright (c) 2005, Google Inc.
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
# 
#     * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#     * Neither the name of Google Inc. nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# ---
# Program for printing the profile generated by common/profiler.cc,
# or by the heap profiler (common/debugallocation.cc)
#
# The profile contains a sequence of entries of the form:
#       <count> <stack trace>
# This program parses the profile, and generates user-readable
# output.
#
# Examples:
#
# % tools/pprof "program" "profile"
#   Generates one line per procedure
#
# % tools/pprof --gv "program" "profile"
#   Generates annotated call-graph and displays via "gv"
#
# % tools/pprof --gv --focus=Mutex "program" "profile"
#   Restrict to code paths that involve an entry that matches "Mutex"
#
# % tools/pprof --gv --focus=Mutex --ignore=string "program" "profile"
#   Restrict to code paths that involve an entry that matches "Mutex"
#   and does not match "string"
#
# % tools/pprof --list=IBF_CheckDocid "program" "profile"
#   Generates disassembly listing of all routines with at least one
#   sample that match the --list=<regexp> pattern.  The listing is
#   annotated with the flat and cumulative sample counts at each line.
#
# % tools/pprof --disasm=IBF_CheckDocid "program" "profile"
#   Generates disassembly listing of all routines with at least one
#   sample that match the --disasm=<regexp> pattern.  The listing is
#   annotated with the flat and cumulative sample counts at each PC value.
#
# TODO: Use color to indicate files?

use strict;
use Getopt::Long;

# These are the external binaries we use.  We hard-code in the path
# because some people have colorizing versions of these binaries which
# can cause trouble.
my $OBJDUMP = "/usr/bin/objdump";
my $NM = "/usr/bin/nm";
my $ADDR2LINE = "/usr/bin/addr2line";
my $DOT = "dot";          # leave non-absolute, since it may be in /usr/local
my $GV = "gv";

##### Argument parsing #####

sub usage_string {
  return <<'EOF';
Usage: pprof [options] <program> <profile>
   Prints specified cpu- or heap-profile 
   
Options:
   --cum               Sort by cumulative data
   --base=<base>       Subtract <base> from <profile> before display
   --interactive       Run in interactive mode (interactive "help" gives help)
   
Reporting Granularity:
   --addresses         Report at address level
   --lines             Report at source line level
   --functions         Report at function level [default]
   --files             Report at source file level
   
Output type:
   --text              Generate text report [default]
   --gv                Generate Postscript and display
   --list=<regexp>     Generate source listing of matching routines
   --disasm=<regexp>   Generate disassembly of matching routines
   --dot               Generate DOT file to stdout
   --ps                Generate Postcript to stdout
   --pdf               Generate PDF to stdout
   --gif               Generate GIF to stdout
   
Heap-Profile Options:
   --inuse_space       Display in-use (mega)bytes [default]
   --inuse_objects     Display in-use objects
   --alloc_space       Display allocated (mega)bytes
   --alloc_objects     Display allocated objects
   --show_bytes        Display space in bytes
   --drop_negative     Ignore negaive differences
   
Call-graph Options:
   --nodecount=<n>     Show at most so many nodes [default=80]
   --nodefraction=<f>  Hide nodes below <f>*total [default=.005]
   --edgefraction=<f>  Hide edges below <f>*total [default=.001]
   --focus=<regexp>    Focus on nodes matching <regexp>
   --ignore=<regexp>   Ignore nodes matching <regexp>
   --scale=<n>         Set GV scaling [default=0]
   
Examples:
   
pprof /bin/ls ls.prof
                       Outputs one line per procedure
pprof --gv /bin/ls ls.prof
                       Displays annotated call-graph via 'gv'
pprof --gv --focus=Mutex /bin/ls ls.prof
                       Restricts to code paths including a .*Mutex.* entry
pprof --gv --focus=Mutex --ignore=string /bin/ls ls.prof
                       Code paths including Mutex but not string
pprof --list=getdir /bin/ls ls.prof
                       (Per-line) annotated source listing for getdir()
pprof --disasm=getdir /bin/ls ls.prof
                       (Per-PC) annotated disassembly for getdir()
EOF
}

sub version_string {
  return <<'EOF'
pprof (part of google-perftools 0.1)

Copyright 1998-2005 Google Inc.

This is BSD licensed software; see the source for copying conditions
and license information.
There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.
EOF
}

sub fatal {
  my $msg = shift;
  print STDERR "$msg\n\n";
  print STDERR usage_string();
  print STDERR "\nFATAL ERROR: $msg\n";    # just as a reminder
  exit(1);
}
  

$main::opt_help = 0;
$main::opt_version = 0;

$main::opt_cum = 0;
$main::opt_base = '';
$main::opt_addresses = 0;
$main::opt_lines = 0;
$main::opt_functions = 0;
$main::opt_files = 0;

$main::opt_text = 0;
$main::opt_list = "";
$main::opt_disasm = "";
$main::opt_gv = 0;
$main::opt_dot = 0;
$main::opt_ps = 0;
$main::opt_pdf = 0;
$main::opt_gif = 0;

$main::opt_nodecount = 80;
$main::opt_nodefraction = 0.005;
$main::opt_edgefraction = 0.001;
$main::opt_focus = '';
$main::opt_ignore = '';
$main::opt_scale = 0;

$main::opt_inuse_space   = 0;
$main::opt_inuse_objects = 0;
$main::opt_alloc_space   = 0;
$main::opt_alloc_objects = 0;
$main::opt_show_bytes    = 0;
$main::opt_drop_negative = 0;
$main::opt_interactive   = 0;

# Are we printing a heap profile?
$main::heap_profile = 0;

# Are we printing a lock profile?
$main::lock_profile = 0;

GetOptions("help!"          => \$main::opt_help,
	   "version!"       => \$main::opt_version,
	   "cum!"           => \$main::opt_cum,
	   "base=s"         => \$main::opt_base,
	   "functions!"     => \$main::opt_functions,
	   "lines!"         => \$main::opt_lines,
	   "addresses!"     => \$main::opt_addresses,
	   "files!"         => \$main::opt_files,
	   "text!"          => \$main::opt_text,
	   "list=s"         => \$main::opt_list,
	   "disasm=s"       => \$main::opt_disasm,
	   "gv!"            => \$main::opt_gv,
	   "dot!"           => \$main::opt_dot,
	   "ps!"            => \$main::opt_ps,
	   "pdf!"           => \$main::opt_pdf,
	   "gif!"           => \$main::opt_gif,
	   "interactive!"   => \$main::opt_interactive,
	   "nodecount=i"    => \$main::opt_nodecount,
	   "nodefraction=f" => \$main::opt_nodefraction,
	   "edgefraction=f" => \$main::opt_edgefraction,
	   "focus=s"        => \$main::opt_focus,
	   "ignore=s"       => \$main::opt_ignore,
	   "scale=i"        => \$main::opt_scale,
	   "inuse_space!"   => \$main::opt_inuse_space,
	   "inuse_objects!" => \$main::opt_inuse_objects,
	   "alloc_space!"   => \$main::opt_alloc_space,
	   "alloc_objects!" => \$main::opt_alloc_objects,
	   "show_bytes!"    => \$main::opt_show_bytes,
	   "drop_negative!" => \$main::opt_drop_negative,
	   ) || fatal("Invalid option(s)");

# Deal with the standard --help and --version
if ($main::opt_help) {
  print usage_string();
  exit(0);
}

if ($main::opt_version) {
  print version_string();
  exit(0);
}

# Disassembly/listing mode requires address-level info
if ($main::opt_disasm || $main::opt_list) {
  $main::opt_functions = 0;
  $main::opt_lines = 0;
  $main::opt_addresses = 1;
  $main::opt_files = 0;
}

# Check heap-profiling flags
if ($main::opt_inuse_space +
    $main::opt_inuse_objects +
    $main::opt_alloc_space +
    $main::opt_alloc_objects > 1) {
  fatal("Specify at most on of --inuse/--alloc options");
}

# Check output granularities
my $grains =
  $main::opt_functions +
  $main::opt_lines +
  $main::opt_addresses +
  $main::opt_files +
  0;
if ($grains > 1) {
  fatal("Only specify one output granularity option");
}
if ($grains == 0) {
  $main::opt_functions = 1;
}

# Check output modes
my $modes =
  $main::opt_text +
  $main::opt_gv +
  $main::opt_dot +
  $main::opt_ps +
  $main::opt_pdf +
  $main::opt_gif +
  0;
if ($modes > 1) {
  fatal("Only specify one output mode");
}
if ($modes == 0) {
  $main::opt_text = 1;
}

my $prog = shift || fatal("Did not specify program");
my $pfile_arg = shift || fatal("Did not specify profile file");

##### Main section #####

# Setup tmp-file name and handler to clean it up
$main::tmpfile_sym = "/tmp/pprof$$.sym";
$main::tmpfile_ps = "/tmp/pprof$$";
$main::next_tmpfile = 0;
$main::collected_profile = undef;
$SIG{'INT'} = \&sighandler;

# Read profile data
my $pfile = FetchDynamicProfile($prog, $pfile_arg);
my $data = ReadProfile($prog, $pfile);
my $profile = $data->{profile};
my $libs = $data->{libs};       # Info about main program and shared libraries

# List of function names to skip
$main::skip = ();
if ($main::heap_profile) {
  foreach my $name ('calloc',
                    'cfree',
                    'malloc',
                    'free',
                    'memalign',
                    'pvalloc',
                    'valloc',
                    'realloc',
                    '__builtin_delete',
                    '__builtin_new',
                    '__builtin_vec_delete',
                    '__builtin_vec_new') {
    $main::skip{$name} = 1;
  }
}
if ($main::lock_profile) {
  foreach my $name ('Mutex::Unlock') {
    $main::skip{$name} = 1;
  }
}

# Subtract base from profile, if specified
if ($main::opt_base ne '') {
  my $base = ReadProfile($prog, $main::opt_base)->{profile};
  $profile = SubtractProfile($profile, $base);
}

# Get total data in profile
my $total = TotalProfile($profile);

# Extract symbols
my $symbols = ExtractSymbols($libs, $profile, $data->{pcs});

# Focus?
if ($main::opt_focus ne '') {
  $profile = FocusProfile($symbols, $profile, $main::opt_focus);
}

# Ignore?
if ($main::opt_ignore ne '') {
  $profile = IgnoreProfile($symbols, $profile, $main::opt_ignore);
}

# Reduce profiles to required output granularity, and also clean
# each stack trace so a given entry exists at most once.
my $reduced = ReduceProfile($symbols, $profile);

# Get derived profiles
my $flat = FlatProfile($reduced);
my $cumulative = CumulativeProfile($reduced);

# Print
if (!$main::opt_interactive) {
  if ($main::opt_disasm) {
    PrintDisassembly($libs, $flat, $cumulative, $main::opt_disasm);
  } elsif ($main::opt_list) {
    PrintListing($libs, $flat, $cumulative, $main::opt_list);
  } elsif ($main::opt_text) {
    PrintText($symbols, $flat, $cumulative, $total, -1);
  } else {
    if (PrintDot($prog, $symbols, $profile, $flat, $cumulative, $total)) {
      if ($main::opt_gv) {
	# Some versions of gv use -scale, and some use --scale.  *sigh*
	# We use --help to determine if gv expects one dash or two.
	system("$GV --help >/dev/null 2>&1 " .
	       "&& $GV --scale=$main::opt_scale $main::tmpfile_ps " .
	       "|| $GV -scale $main::opt_scale $main::tmpfile_ps")
      }
    } else {
      exit(1);
    }
  }
} else {
  InteractiveMode();
}

cleanup();
exit(0);


##### Interactive helper routines #####
sub InteractiveMode {
  $| = 1;	# Make output unbuffered for interactive mode
  my $orig_profile = $profile;
  while (1) {
    print "(pprof) ";
    $_ = <STDIN>;
    if (!defined($_)) {
      print "\n";
      last;
    }
    if (m/^ *quit/) {
      last;
    }
    if (m/^ *help/) {
      InteractiveHelpMessage();
      next;
    }
    # Clear all the options
    $main::opt_lines = 0;
    $main::opt_text = 0;
    $main::opt_disasm = 0;
    $main::opt_list = 0;
    $main::opt_gv = 0;
    $main::opt_cum = 0;

    if (m/^ *(text|top)(\d*) *(.*)/) {
      $main::opt_text = 1;

      my $line_limit = ($2 ne "") ? int($2) : 10;

      my $routine;
      my $ignore;
      ($routine, $ignore) = ParseInteractiveArgs($3);

      my $profile = ProcessProfile($orig_profile, "", $ignore);
      my $reduced = ReduceProfile($symbols, $profile);

      # Get derived profiles
      my $flat = FlatProfile($reduced);
      my $cumulative = CumulativeProfile($reduced);

      PrintText($symbols, $flat, $cumulative, $total, $line_limit);
      next;
    }
    if (m/^ *list *(.+)/) {
      $main::opt_list = 1;

      my $routine;
      my $ignore;
      ($routine, $ignore) = ParseInteractiveArgs($1);

      my $profile = ProcessProfile($orig_profile, "", $ignore);
      my $reduced = ReduceProfile($symbols, $profile);

      # Get derived profiles
      my $flat = FlatProfile($reduced);
      my $cumulative = CumulativeProfile($reduced);

      PrintListing($libs, $flat, $cumulative, $routine);
      next;
    }
    if (m/^ *disasm *(.+)/) {
      $main::opt_disasm = 1;

      my $routine;
      my $ignore;
      ($routine, $ignore) = ParseInteractiveArgs($1);

      # Process current profile to account for various settings
      my $profile = ProcessProfile($orig_profile, "", $ignore);
      my $reduced = ReduceProfile($symbols, $profile);

      # Get derived profiles
      my $flat = FlatProfile($reduced);
      my $cumulative = CumulativeProfile($reduced);

      PrintDisassembly($libs, $flat, $cumulative, $routine);
      next;
    }
    if (m/^ *gv *(.*)/) {
      $main::opt_gv = 1;

      my $focus;
      my $ignore;
      ($focus, $ignore) = ParseInteractiveArgs($1);

      # Process current profile to account for various settings
      my $profile = ProcessProfile($orig_profile, $focus, $ignore);
      my $reduced = ReduceProfile($symbols, $profile);

      # Get derived profiles
      my $flat = FlatProfile($reduced);
      my $cumulative = CumulativeProfile($reduced);

      if (PrintDot($prog, $symbols, $profile, $flat, $cumulative, $total)) {
	system("gv -scale $main::opt_scale -noresize " . 
	       PsTempName($main::next_tmpfile) . " &");
	$main::next_tmpfile++;
      }
      next;
    }
  }
}


sub ProcessProfile {
  my $orig_profile = shift;
  my $focus = shift;
  my $ignore = shift;

  # Process current profile to account for various settings
  my $profile = $orig_profile;
  my $total_count = TotalProfile($profile);
  print "Total: ", $total_count, " samples\n";
  if ($focus ne '') {
    $profile = FocusProfile($symbols, $profile, $focus);
    my $focus_count = TotalProfile($profile);
    printf "After focusing on '%s': %d samples of %d (%0.1f%%)\n", 
      $focus, $focus_count, $total_count, ($focus_count*100.0) / $total_count;
  }
  if ($ignore ne '') {
    $profile = IgnoreProfile($symbols, $profile, $ignore);
    my $ignore_count = TotalProfile($profile);
    printf "After ignoring '%s': %d samples of %d (%0.1f%%)\n", 
      $ignore, $ignore_count, $total_count, 
	($ignore_count*100.0) / $total_count;
  }

  return $profile;
}

sub InteractiveHelpMessage {
  print <<ENDOFHELP;
Interactive pprof mode

Commands:
  gv
  gv [focus] [-ignore1] [-ignore2]
      Show graphical hierarchical display of current profile.  Without
      any arguments, shows all samples in the profile.  With the optional
      "focus" argument, restricts the samples shown to just those where
      the "focus" regular expression matches a routine name on the stack 
      trace.

  list [routine_regexp] [-ignore1] [-ignore2]
      Show source listing of routines whose names match "routine_regexp"
  
  top [--cum] [-ignore1] [-ignore2]
  top20 [--cum] [-ignore1] [-ignore2]
  top37 [--cum] [-ignore1] [-ignore2]
      Show top lines ordered by flat profile count, or cumulative count
      if --cum is specified.  If a number is present after 'top', the
      top K routines will be shown (defaults to showing the top 10)
  
  disasm [routine_regexp] [-ignore1] [-ignore2]
      Show disassembly of routines whose names match "routine_regexp",
      annotated with sample counts.

  help - This listing
  quit or ^D - End pprof

For commands that accept optional -ignore tags, samples where any routine in
the stack trace matches the regular expression in any of the -ignore
parameters will be ignored.

ENDOFHELP
}
sub ParseInteractiveArgs {
  my $args = shift;
  my $focus = "";
  my $ignore = "";
  my @x = split(/ +/, $args);
  foreach $a (@x) {
    if ($a =~ m/^(--|-)lines$/) {
      $main::opt_lines = 1;
    } elsif ($a =~ m/^(--|-)cum$/) {
      $main::opt_cum = 1;
    } elsif ($a =~ m/^-(.*)/) {
      $ignore .= (($ignore ne "") ? "|" : "" ) . $1;
    } else {
      $focus .= (($focus ne "") ? "|" : "" ) . $a;
    }
  }
  if ($ignore ne "") {
    print "Ignoring samples in call stacks that match '$ignore'\n";
  }
  return ($focus, $ignore);
}

##### Output code #####

sub PsTempName {
  my $fnum = shift;
  return "$main::tmpfile_ps" . "." . "$fnum" . ".ps";
}
  
# Print text output
sub PrintText {
  my $symbols = shift;
  my $flat = shift;
  my $cumulative = shift;
  my $total = shift;
  my $line_limit = shift;

  # Which profile to sort by?
  my $s = $main::opt_cum ? $cumulative : $flat;

  my $running_sum = 0;
  my $lines = 0;
  foreach my $k (sort { GetEntry($s,$b) <=> GetEntry($s, $a) }
                 keys(%{$cumulative})) {
    my $f = GetEntry($flat, $k);
    my $c = GetEntry($cumulative, $k);
    $running_sum += $f;

    my $sym = $k;
    if (exists($symbols->{$k})) {
      $sym = $symbols->{$k}->[0] . " " . $symbols->{$k}->[1];
      if ($main::opt_addresses) {
        $sym = $k . " " . $sym;
      }
    }

    if ($f != 0 || $c != 0) {
      printf("%8s %6s %6s %8s %6s %s\n",
             Unparse($f),
             Percent($f, $total),
             Percent($running_sum, $total),
             Unparse($c),
             Percent($c, $total),
             $sym);
    }
    $lines++;
    last if ($line_limit >= 0 && $lines > $line_limit);
  }
}

# Print disassembly for all all routines that match $main::opt_disasm
sub PrintDisassembly {
  my $libs = shift;
  my $flat = shift;
  my $cumulative = shift;
  my $disasm_opts = shift;

  foreach my $lib (@{$libs}) {
    my $symbol_table = GetProcedureBoundaries($lib->[0], $disasm_opts);
    my $offset = $lib->[1] - $lib->[3];
    foreach my $routine (keys(%{$symbol_table})) {
      my $start_addr = $symbol_table->{$routine}->[0];
      my $end_addr = $symbol_table->{$routine}->[1];
      # See if there are any samples in this routine
      my $total_flat = 0;
      my $total_cum = 0;
      for (my $addr = $start_addr; $addr < $end_addr; $addr++) {
        $total_flat += GetEntry($flat, sprintf("0x%x", $addr+$offset));
        $total_cum += GetEntry($cumulative, sprintf("0x%x", $addr+$offset));
      }

      # Skip disassembly if there are no samples in routine
      next if ($total_cum == 0);

      print "ROUTINE ====================== $routine\n";
      printf "%6s %6s Total samples (flat / cumulative)\n",
        Unparse($total_flat), Unparse($total_cum);

      my @instructions = Disassemble($lib->[0], $offset,
                                     $start_addr, $end_addr);
      foreach my $e (@instructions) {
        my $location = ($e->[2] >= 0) ? "$e->[1]:$e->[2]" : "";
        $location =~ s|.*/||;   # Remove directory portion, if any
        if (length($location) >= 20) {
          # For long locations, just show the last 20 characters
          $location = substr($location, -20);
        }
        my $f = GetEntry($flat, $e->[0]);
        my $c = GetEntry($cumulative, $e->[0]);
        my $address = $e->[0];  $address =~ s/^0x//;
        printf("%6s %6s %-20s %8s: %6s\n",
               UnparseAlt($f),
               UnparseAlt($c),
               $location,
               $address,
               $e->[3]);
      }
      close(OBJDUMP);
    }
  }
}

# Return reference to array of tuples of the form:
#       [address, filename, linenumber, instruction]
# E.g.,
#       ["0x806c43d", "/foo/bar.cc", 131, "ret"]
sub Disassemble {
  my $prog = shift;
  my $offset = shift;
  my $start_addr = shift;
  my $end_addr = shift;

  my $cmd = sprintf("$OBJDUMP -d -l --no-show-raw-insn " .
                    "--start-address=%d --stop-address=%d $prog",
                    $start_addr, $end_addr);
  open(OBJDUMP, "$cmd |") || error("$OBJDUMP: $!\n");
  my @result = ();
  my $filename = "";
  my $linenumber = -1;
  while (<OBJDUMP>) {
    chop;
    if (m|\s*([^:\s]+):(\d+)\s*$|) {
      # Location line of the form:
      #   <filename>:<linenumber>
      $filename = $1;
      $linenumber = $2;
    } elsif (m/^ +([0-9a-f]+):\s*(.*)/) {
      # Disassembly line
      my $k = sprintf("0x%x", hex($1) + $offset);
      push(@result, [$k, $filename, $linenumber, $2]);
    }
  }
  close(OBJDUMP);
  return @result;
}

# For sorting functions by name
sub ByName {
  return ShortFunctionName($a) cmp ShortFunctionName($b);
}

# Print source-listing for all all routines that match $main::opt_list
sub PrintListing {
  my $libs = shift;
  my $flat = shift;
  my $cumulative = shift;
  my $list_opts = shift;

  foreach my $lib (@{$libs}) {
    my $symbol_table = GetProcedureBoundaries($lib->[0], $list_opts);
    my $offset = $lib->[1] - $lib->[3];
    foreach my $routine (sort ByName keys(%{$symbol_table})) {
      # Print if there are any samples in this routine
      my $start_addr = $symbol_table->{$routine}->[0];
      my $end_addr = $symbol_table->{$routine}->[1];
      for (my $addr = $start_addr; $addr < $end_addr; $addr++) {
        if (defined($cumulative->{sprintf("0x%x", $addr+$offset)})) {
          PrintSource($lib->[0], $offset,
                      $routine, $flat, $cumulative,
                      $start_addr, $end_addr);
          last;
        }
      }
    }
  }
}

# Returns the indentation of the line, if it has any non-whitespace
# characters.  Otherwise, returns -1.
sub Indentation {
  my $line = shift;
  if (m/^(\s*)\S/) {
    return length($1);
  } else {
    return -1;
  }
}

# Print source-listing for one routine
sub PrintSource {
  my $prog = shift;
  my $offset = shift;
  my $routine = shift;
  my $flat = shift;
  my $cumulative = shift;
  my $start_addr = shift;
  my $end_addr = shift;

  # Disassemble all instructions (just to get line numbers)
  my @instructions = Disassemble($prog, $offset, $start_addr, $end_addr);

  # Hack 1: assume that the last source location mentioned in the
  # disassembly is the end of the source code.
  my $filename = undef;
  my $lastline = -1;
  for (my $i = $#instructions; $i >= 0; $i--) {
    if ($instructions[$i]->[2] >= 0) {
      $filename = $instructions[$i]->[1];
      $lastline = $instructions[$i]->[2];
      last;
    }
  }
  if (!defined($filename)) {
    print STDERR "no filename found in $routine\n";
    return;
  }

  # Hack 2: assume the first source location from "filename" is the start of
  # the source code.
  my $firstline = 1;
  for (my $i = 0; $i <= $#instructions; $i++) {
    if ($instructions[$i]->[1] eq $filename) {
      $firstline = $instructions[$i]->[2];
      last;
    }
  }

  # Hack 3: Extend last line forward until its indentation is less than 
  # the indentation we saw on $firstline
  my $oldlastline = $lastline;
  {
    if (!open(FILE, "<$filename")) {
      print STDERR "$filename: $!\n";
      return;
    }
    my $l = 0;
    my $first_indentation = -1;
    while (<FILE>) {
      $l++;
      my $indent = Indentation($_);
      if ($l >= $firstline) {
	if ($first_indentation < 0 && $indent >= 0) {
	  $first_indentation = $indent;
	  last if ($first_indentation == 0);
	}
      }
      if ($l >= $lastline && $indent >= 0) {
	if ($indent >= $first_indentation) {
	  $lastline = $l+1;
	} else {
	  last;
	}
      }
    }
    close(FILE);
  }

  # Assign all samples to the range $firstline,$lastline,
  # Hack 4: If an instruction does not occur in the range, its samples
  # are moved to the next instruction that occurs in the range.
  my $samples1 = {};
  my $samples2 = {};
  my $running1 = 0;     # Unassigned flat counts
  my $running2 = 0;     # Unassigned cumulative counts
  my $total1 = 0;       # Total flat counts
  my $total2 = 0;       # Total cumulative counts
  foreach my $e (@instructions) {
    my $c1 = GetEntry($flat, $e->[0]);
    my $c2 = GetEntry($cumulative, $e->[0]);
    $running1 += $c1;
    $running2 += $c2;
    $total1 += $c1;
    $total2 += $c2;
    my $file = $e->[1];
    my $line = $e->[2];
    if (($file eq $filename) &&
        ($line >= $firstline) &&
        ($line <= $lastline)) {
      # Assign all accumulated samples to this line
      AddEntry($samples1, $line, $running1);
      AddEntry($samples2, $line, $running2);
      $running1 = 0;
      $running2 = 0;
    }
  }

  # Assign any leftover samples to $lastline
  AddEntry($samples1, $lastline, $running1);
  AddEntry($samples2, $lastline, $running2);

  printf("ROUTINE ====================== %s in %s\n" .
         "%6s %6s Total %s (flat / cumulative)\n",
         ShortFunctionName($routine),
         $filename,
         Units(),
         Unparse($total1),
         Unparse($total2));
  if (!open(FILE, "<$filename")) {
    print STDERR "$filename: $!\n";
    return;
  }
  my $l = 0;
  while (<FILE>) {
    $l++;
    if ($l >= $firstline - 5 && 
	(($l <= $oldlastline + 5) || ($l <= $lastline))) {
      chop;
      my $text = $_;
      printf("%6s %6s %4d: %s\n",
             UnparseAlt(GetEntry($samples1, $l)),
             UnparseAlt(GetEntry($samples2, $l)),
             $l,
             $text);
    };
  }
  close(FILE);
}

# Print DOT graph
sub PrintDot {
  my $prog = shift;
  my $symbols = shift;
  my $raw = shift;
  my $flat = shift;
  my $cumulative = shift;
  my $overall_total = shift;

  # Get total
  my $local_total = TotalProfile($flat);
  my $nodelimit = int($main::opt_nodefraction * $local_total);
  my $edgelimit = int($main::opt_edgefraction * $local_total);
  my $nodecount = $main::opt_nodecount;

  # Find nodes to include
  my @list = (sort { abs(GetEntry($cumulative, $b)) <=>
                     abs(GetEntry($cumulative, $a)) }
              keys(%{$cumulative}));
  my $last = $nodecount - 1;
  if ($last > $#list) {
    $last = $#list;
  }
  while (($last >= 0) &&
         (abs(GetEntry($cumulative, $list[$last])) <= $nodelimit)) {
    $last--;
  }
  if ($last < 0) {
    print STDERR "No nodes to print\n";
    cleanup();
    return 0;
  }

  if ($nodelimit > 0 || $edgelimit > 0) {
    printf STDERR ("Dropping nodes with <= %s %s; edges with <= %s abs(%s)\n",
		   Unparse($nodelimit), Units(),
		   Unparse($edgelimit), Units());
  }

  # Open DOT output file
  my $output;
  if ($main::opt_gv) {
    $output = "| $DOT -Tps >" . PsTempName($main::next_tmpfile);
  } elsif ($main::opt_ps) {
    $output = "| $DOT -Tps";
  } elsif ($main::opt_pdf) {
    $output = "| $DOT -Tps | ps2pdf - -";
  } elsif ($main::opt_gif) {
    $output = "| $DOT -Tgif";
  } else {
    $output = ">&STDOUT";
  }
  open(DOT, $output) || error("$output: $!\n");

  # Title
  printf DOT ("digraph \"%s; %s %s\" {\n",
              $prog,
              Unparse($overall_total),
              Units());
  if ($main::opt_pdf) {
    # The output is more printable if we set the page size for dot.
    printf DOT ("size=\"8,11\"\n");
  }
  printf DOT ("node [width=0.375,height=0.25];\n");

  # Print legend
  printf DOT ("Legend [shape=box,fontsize=24,shape=plaintext," .
              "label=\"%s\\l%s\\l%s\\l%s\\l%s\\l\"];\n",
              $prog,
              sprintf("Total %s: %s", Units(), Unparse($overall_total)),
              sprintf("Focusing on: %s", Unparse($local_total)),
              sprintf("Dropped nodes with <= %s abs(%s)",
                      Unparse($nodelimit), Units()),
              sprintf("Dropped edges with <= %s %s",
                      Unparse($edgelimit), Units())
              );

  # Print nodes
  my %node = ();
  my $nextnode = 1;
  foreach my $a (@list[0..$last]) {
    # Pick font size
    my $f = GetEntry($flat, $a);
    my $c = GetEntry($cumulative, $a);

    my $fs = 8;
    if ($local_total > 0) {
      $fs = 8 + (50.0 * sqrt(abs($f * 1.0 / $local_total)));
    }

    $node{$a} = $nextnode++;
    my $sym = $a;
    $sym =~ s/\s+/\\n/g;
    $sym =~ s/::/\\n/g;

    # Extra cumulative info to print for non-leaves
    my $extra = "";
    if ($f != $c) {
      $extra = sprintf("\\rof %s (%s)",
                       Unparse($c),
                       Percent($c, $overall_total));
    }
    printf DOT ("N%d [label=\"%s\\n%s (%s)%s\\r" .
                "\",shape=box,fontsize=%.1f];\n",
                $node{$a},
                $sym,
                Unparse($f),
                Percent($f, $overall_total),
                $extra,
                $fs,
               );
  }

  # Get edges and counts per edge
  my %edge = ();
  foreach my $k (keys(%{$raw})) {
    # TODO: omit low %age edges
    my $n = $raw->{$k};
    my @addrs = split(/\n/, $k);
    for (my $i = 1; $i <= $#addrs; $i++) {
      my $src = OutputKey($symbols, $addrs[$i]);
      my $dst = OutputKey($symbols, $addrs[$i-1]);
      #next if ($src eq $dst);  # Avoid self-edges?
      if (exists($node{$src}) && exists($node{$dst})) {
        my $e = "$src\001$dst";
        if (!exists($edge{$e})) {
          $edge{$e} = 0;
        }
        $edge{$e} += $n;
      }
    }
  }

  # Print edges
  foreach my $e (keys(%edge)) {
    my @x = split(/\001/, $e);
    my $n = $edge{$e};

    if (abs($n) > $edgelimit) {
      # Compute line width based on edge count
      my $fraction = abs($local_total ? (3 * ($n / $local_total)) : 0);
      if ($fraction > 1) { $fraction = 1; }
      my $w = $fraction * 2;
      #if ($w < 1) { $w = 1; }

      # Use a slightly squashed function of the edge count as the weight
      printf DOT ("N%s -> N%s [label=%s, weight=%d, " .
                  "style=\"setlinewidth(%f)\"];\n",
                  $node{$x[0]},
                  $node{$x[1]},
                  Unparse($n),
                  int(abs($n) ** 0.7),
                  $w);
    }
  }

  print DOT ("}\n");

  close(DOT);
  return 1;
}

# Generate the key under which a given address should be counted
# based on the user-specified output granularity.
sub OutputKey {
  my $symbols = shift;
  my $a = shift;

  # Skip large addresses since they sometimes show up as fake entries on RH9
  if (hex($a) > 0x7fffffff) {
    return '';
  }

  # Extract symbolic info for address
  my $func = $a;
  my $fullfunc = $a;
  my $fileline = "";
  if (exists($symbols->{$a})) {
    $func = $symbols->{$a}->[0];
    $fullfunc = $symbols->{$a}->[2];
    $fileline = $symbols->{$a}->[1];
  }

  # We drop a few well-known names
  if ($main::skip{$func}) {
    return '';
  }

  if ($main::opt_disasm || $main::opt_list) {
    return $a;   # We want just the address for the key
  } elsif ($main::opt_addresses) {
    return "$a $func $fileline";
  } elsif ($main::opt_lines) {
    return "$func $fileline";
  } elsif ($main::opt_functions) {
    return $func;
  } elsif ($main::opt_files) {
    my $f = ($fileline eq '') ? $a : $fileline;
    $f =~ s/:\d+$//;
    return $f;
  } else {
    return $a;
  }
}

# Generate percent string for a number and a total
sub Percent {
  my $num = shift;
  my $tot = shift;
  if ($tot != 0) {
    return sprintf("%.1f%%", $num * 100.0 / $tot);
  } else {
    return ($num == 0) ? "nan" : (($num > 0) ? "+inf" : "-inf");
  }
}

# Generate pretty-printed form of number
sub Unparse {
  my $num = shift;
  if ($main::heap_profile) {
    if ($main::opt_inuse_objects || $main::opt_alloc_objects) {
      return sprintf("%d", $num);
    } else {
      if ($main::opt_show_bytes) {
        return sprintf("%d", $num);
      } else {
        return sprintf("%.1f", $num / 1048576.0);
      }
    }
  } else {
    return sprintf("%d", $num);
  }
}

# Alternate pretty-printed form: 0 maps to "."
sub UnparseAlt {
  my $num = shift;
  if ($num == 0) {
    return ".";
  } else {
    return Unparse($num);
  }
}

# Return output units
sub Units {
  if ($main::heap_profile) {
    if ($main::opt_inuse_objects || $main::opt_alloc_objects) {
      return "objects";
    } else {
      if ($main::opt_show_bytes) {
        return "B";
      } else {
        return "MB";
      }
    }
  } else {
    return "samples";
  }
}

##### Profile manipulation code #####

# Generate flattened profile:
# If count is charged to stack [a,b,c,d], in generated profile,
# it will be charged to [a]
sub FlatProfile {
  my $profile = shift;
  my $result = {};
  foreach my $k (keys(%{$profile})) {
    my $count = $profile->{$k};
    my @addrs = split(/\n/, $k);
    AddEntry($result, $addrs[0], $count);
  }
  return $result;
}

# Generate cumulative profile:
# If count is charged to stack [a,b,c,d], in generated profile,
# it will be charged to [a], [b], [c], [d]
sub CumulativeProfile {
  my $profile = shift;
  my $result = {};
  foreach my $k (keys(%{$profile})) {
    my $count = $profile->{$k};
    my @addrs = split(/\n/, $k);
    foreach my $a (@addrs) {
      AddEntry($result, $a, $count);
    }
  }
  return $result;
}

# Reduce profile to granularity given by user
sub ReduceProfile {
  my $symbols = shift;
  my $profile = shift;
  my $result = {};
  foreach my $k (keys(%{$profile})) {
    my $count = $profile->{$k};
    my @addrs = split(/\n/, $k);
    my @path = ();
    my %seen = ();
    $seen{''} = 1;      # So that empty keys are skipped
    foreach my $a (@addrs) {
      # To avoid double-counting due to recursion, skip a stack-trace
      # entry if it has already been seen
      my $key = OutputKey($symbols, $a);
      if (!$seen{$key}) {
        $seen{$key} = 1;
        push(@path, $key);
      }
    }
    my $reduced_path = join("\n", @path);
    AddEntry($result, $reduced_path, $count);
  }
  return $result;
}

# Focus only on paths involving specified regexps
sub FocusProfile {
  my $symbols = shift;
  my $profile = shift;
  my $focus = shift;
  my $result = {};
  foreach my $k (keys(%{$profile})) {
    my $count = $profile->{$k};
    my @addrs = split(/\n/, $k);
    foreach my $a (@addrs) {
      # Reply if it matches either the address/shortname/fileline
      if (($a =~ m/$focus/) ||
          (exists($symbols->{$a}) &&
           (($symbols->{$a}->[0] =~ m/$focus/) ||
            ($symbols->{$a}->[1] =~ m/$focus/)))) {
        AddEntry($result, $k, $count);
        last;
      }
    }
  }
  return $result;
}

# Focus only on paths not involving specified regexps
sub IgnoreProfile {
  my $symbols = shift;
  my $profile = shift;
  my $ignore = shift;
  my $result = {};
  foreach my $k (keys(%{$profile})) {
    my $count = $profile->{$k};
    my @addrs = split(/\n/, $k);
    my $matched = 0;
    foreach my $a (@addrs) {
      # Reply if it matches either the address/shortname/fileline
      if (($a =~ m/$ignore/) ||
          (exists($symbols->{$a}) &&
           (($symbols->{$a}->[0] =~ m/$ignore/) ||
            ($symbols->{$a}->[1] =~ m/$ignore/)))) {
        $matched = 1;
        last;
      }
    }
    if (!$matched) {
      AddEntry($result, $k, $count);
    }
  }
  return $result;
}

# Get total count in profile
sub TotalProfile {
  my $profile = shift;
  my $result = 0;
  foreach my $k (keys(%{$profile})) {
    $result += $profile->{$k};
  }
  return $result;
}

# Subtract B from A
sub SubtractProfile {
  my $A = shift;
  my $B = shift;

  my $R = {};
  foreach my $k (keys(%{$A})) {
    my $v = $A->{$k} - GetEntry($B, $k);
    if ($v < 0 && $main::opt_drop_negative) {
      $v = 0;
    }
    AddEntry($R, $k, $v);
  }
  if (!$main::opt_drop_negative) {
    # take care of when substracted profile has more things
    foreach my $k (keys(%{$B})) {
      if (!exists($A->{$k})) {
        AddEntry($R, $k, 0 - $B->{$k});
      }
    }
  }
  return $R;
}

# Get entry from profile; zero if not present
sub GetEntry {
  my $profile = shift;
  my $k = shift;
  if (exists($profile->{$k})) {
    return $profile->{$k};
  } else {
    return 0;
  }
}

# Add entry to specified profile
sub AddEntry {
  my $profile = shift;
  my $k = shift;
  my $n = shift;
  if (!exists($profile->{$k})) {
    $profile->{$k} = 0;
  }
  $profile->{$k} += $n;
}

##### Code to profile a server dynamically #####

sub FetchDynamicProfile {
  my $binary_name = shift;
  my $profile_name = shift;

  # TODO: Add support for fetching profiles dynamically from a server
  return $profile_name;
}

##### Parsing code #####

# Parse profile generated by common/profiler.cc and return a reference
# to a map:
#      $result->{version}     Version number of profile file
#      $result->{period}      Sampling period (in microseconds)
#      $result->{profile}     Profile object
#      $result->{map}         Memory map info from profile
#      $result->{pcs}         List of all PC values seen
sub ReadProfile {
  my $prog = shift;
  my $fname = shift;

  $main::heap_profile = 0;
  $main::lock_profile = 0;

  # Look at first line to see if it is a heap or a CPU profile
  open(PROFILE, "<$fname") || error("$fname: $!\n");
  binmode PROFILE;      # New perls do UTF-8 processing
  my $header = <PROFILE>;
  if ($header =~ m/^heap profile:/) {
    $main::heap_profile = 1;
    return ReadHeapProfile($prog, $fname, $header);
  } elsif ($header =~ m/^--- *contentionz/ ) {
    $main::lock_profile = 1;
    return ReadSynchProfile($prog, $fname);
  } elsif ($header =~ m/^--- *Stacks:/ ) {
    print STDERR
      "Old format contention profile: mistakenly reports " .
      "condition variable signals as lock contentions.\n";
    $main::lock_profile = 1;
    return ReadSynchProfile($prog, $fname);
  } else {
    # Need to unread the line we just read
    close(PROFILE);
    open(PROFILE, "<$fname") || error("$fname: $!\n");
    binmode PROFILE;    # New perls do UTF-8 processing
    return ReadCPUProfile($prog, $fname);
  }
}

# CPU profile reader
sub ReadCPUProfile {
  my $prog = shift;
  my $fname = shift;

  # Read entire profile into a string
  my $str;
  my $nbytes = read(PROFILE, $str, (stat PROFILE)[7]);   # read entire file
  close(PROFILE);

  # Parse string into array of slots.
  # L! is needed for 64-bit # platforms, but not supported on 5.005
  # (despite the manpage claims)

  my $format;
  if ($] >= 5.008) {
      $format = "L!*";
  } else {
      $format = "L*";
  }

  my @slots = unpack($format, $str);

  # Read header
  if ($#slots < 1 || $slots[0] != 0 || $slots[1] < 3) {
    error("$fname: not a profile file, or old format profile file\n");
  }
  my $version = $slots[2];
  my $period = $slots[3];
  my $i = 2 + $slots[1];

  # Parse profile
  my $profile = {};
  my $pcs = {};
  while ($i <= $#slots) {
    my $n = $slots[$i++];
    my $d = $slots[$i++];
    if ($slots[$i] == 0) {
      # End of profile data marker
      $i += $d;
      last;
    }

    # Make key out of the stack entries
    my $k = "";
    for (my $j = 0; $j < $d; $j++) {
      my $pc = $slots[$i+$j];
      $pcs->{$pc} = 1;
      $k .= sprintf("\n0x%x", $pc);
    }
    $k =~ s/^\n//;

    AddEntry($profile, $k, $n);
    $i += $d;
  }

  # Parse map
  my $map = substr($str, $i * 4);

  my $r = {};
  $r->{version} = $version;
  $r->{period} = $period;
  $r->{profile} = $profile;
  $r->{libs} = ParseLibraries($prog, $map, $pcs);
  $r->{pcs} = $pcs;

  return $r;
}

sub ReadHeapProfile {
  my $prog = shift;
  my $fname = shift;
  my $header = shift;

  my $index = 1;
  if ($main::opt_inuse_space) {
    $index = 1;
  } elsif ($main::opt_inuse_objects) {
    $index = 0;
  } elsif ($main::opt_alloc_space) {
    $index = 3;
  } elsif ($main::opt_alloc_objects) {
    $index = 2;
  }

  # Find the type of this profile
  chomp($header);
  my $type = "unknown";
  if ($header =~ m/^heap profile:\s*(\d+):\s+(\d+)\s+\[\s*(\d+):\s+(\d+)\](\s*@\s*(.*))?/) {
    if (defined($6) && ($6 ne '')) {
      $type = $6;
    }
  }

  my $profile = {};
  my $pcs = {};
  my $map = "";
  while (<PROFILE>) {
    if (/^MAPPED_LIBRARIES:/) {
      # Read the /proc/self/maps data
      while (<PROFILE>) {
        $map .= $_;
      }
      last;
    }

    if (/^--- Memory map:/) {
      # Read /proc/self/maps data as formatted by DumpAddressMap()
      my $buildvar = "";
      while (<PROFILE>) {
	# Parse "build=<dir>" specification if supplied
	if (m/^\s*build=(.*)\n/) {
	  $buildvar = $1;
	}

	# Expand "$build" variable if available
	$_ =~ s/\$build\b/$buildvar/g;

        $map .= $_;
      }
      last;
    }

    # Read entry of the form:
    #  <count1>: <bytes1> [<count2>: <bytes2>] @ a1 a2 a3 ... an
    s/^\s*//;
    s/\s*$//;
    if (m/^\s*(\d+):\s+(\d+)\s+\[\s*(\d+):\s+(\d+)\]\s+@\s+(.*)$/) {
      my $stack = $5;
      my ($n1, $s1, $n2, $s2) = ($1, $2, $3, $4);

      my @counts = ($n1, $s1, $n2, $s2);
      my $n = $counts[$index];
      my $k = "";
      foreach my $e (split(/\s+/, $stack)) {
        my $pc = hex($e);
        $pcs->{$pc} = 1;
        $k .= sprintf("\n0x%x", $pc);
      }
      $k =~ s/^\n//;
      AddEntry($profile, $k, $n);
    }
  }

  my $r = {};
  $r->{version} = "heap";
  $r->{period} = 1;
  $r->{profile} = $profile;
  $r->{libs} = ParseLibraries($prog, $map, $pcs);
  $r->{pcs} = $pcs;
  return $r;
}

sub ReadSynchProfile {
  my ($prog, $fname, $header) = @_;
  my ($line, $map, $pc, @k, $count, $stack);

  $map = '';
  my $profile = {};
  my $pcs = {};
  my $sampling_period = 1;

  while ( $line = <PROFILE> ) {
    if ( $line =~ /^(slow release).*thread \d+  \@\s*(.*?)\s*$/ ||
         $line =~ /^\s*(\d+) \@\s*(.*?)\s*$/ ) {
      # Sample entry
      ($count, $stack) = ($1, $2);
      $count = 1 if $count !~ /^\d+$/;

      @k = ();
      foreach $pc (split /\s+/, $stack) {
        $pcs->{hex($pc)} = 1;
        push @k, $pc;
      }
      AddEntry($profile, (join "\n", @k), $count);
    } elsif ( $line =~ /sampling period = (\d+)/ ) {
      $sampling_period = $1;
    } else {
      # Memory map entry
      $map .= $line;
    }
  }
  close PROFILE;

  my $r = {};
  $r->{'version'} = 0;
  $r->{'period'} = $sampling_period;
  $r->{'profile'} = $profile;
  $r->{'libs'} = ParseLibraries($prog, $map, $pcs);
  $r->{'pcs'} = $pcs;
  return $r;
}

##### Symbol extraction #####

# Split /proc/pid/maps dump into a list of libraries
sub ParseLibraries {
  my $prog = shift;
  my $map = shift;
  my $pcs = shift;

  my $result = [];
  my $h = "[a-f0-9]+";
  foreach my $l (split("\n", $map)) {
    my $start;
    my $finish;
    my $offset;
    my $lib;
    if ($l =~ /^($h)-($h)\s+..x.\s+($h)\s+\S+:\S+\s+\d+\s+(\S+\.so(\.\d+)*\w*)/) {
      # Full line from /proc/self/maps.  Example:
      #   40000000-40015000 r-xp 00000000 03:01 12845071   /lib/ld-2.3.2.so
      $start = hex($1);
      $finish = hex($2);
      $offset = hex($3);
      $lib = $4;
    } elsif ($l =~ /^\s*($h)-($h):\s*(\S+\.so(\.\d+)*)/) {
      # Cooked line from DumpAddressMap.  Example:
      #   40000000-40015000: /lib/ld-2.3.2.so
      $start = hex($1);
      $finish = hex($2);
      $offset = 0;
      $lib = $3;
    } else {
      next;
    }

    # Get objdump output from the library file to figure out how to
    # map between mapped addresses and addresses in the library.
    open(OBJDUMP, "$OBJDUMP -h $lib |") || error("$OBJDUMP $lib: $!\n");
    while (<OBJDUMP>) {
      # Idx Name          Size      VMA       LMA       File off  Algn
      #  10 .text         00104b2c  420156f0  420156f0  000156f0  2**4
      my @x = split;
      if (($#x >= 6) && ($x[1] eq '.text')) {
        my $vma = hex($x[3]);
        my $file_offset = hex($x[5]);
        $offset += $vma - $file_offset;
        last;
      }
    }
    close(OBJDUMP);

    push(@{$result}, [$lib, $start, $finish, $offset]);
  }

  # Append special entry for the main program
  my $max_pc = 0;
  foreach my $pc (keys(%{$pcs})) {
    if ($pc > $max_pc) { $max_pc = $pc; }
  }
  push(@{$result}, [$prog, 0, $max_pc, 0]);

  return $result;
}

# Extract symbols for all PC values found in profile
sub ExtractSymbols {
  my $libs = shift;
  my $profile = shift;
  my $pcset = shift;

  my $symbols = {};

  # Map each PC value to the containing library
  my %seen = ();
  foreach my $lib (@{$libs}) {
    my $libname = $lib->[0];
    my $start = $lib->[1];
    my $finish = $lib->[2];
    my $offset = $lib->[3];

    # Get list of pcs that belong in this library.
    my $contained = [];
    foreach my $pc (keys(%{$pcset})) {
      if (!$seen{$pc} && ($pc >= $start) && ($pc <= $finish)) {
        $seen{$pc} = 1;
        push(@{$contained}, $pc);
      }
    }
    # Map to symbols
    MapToSymbols($libname, $start - $offset, $contained, $symbols);
  }

  return $symbols;
}

# Map list of PC values to symbols for a given image
sub MapToSymbols {
  my $image = shift;
  my $offset = shift;
  my $pclist = shift;
  my $symbols = shift;

  # Ignore empty binaries
  if ($#{$pclist} < 0) { return; }

  MapSymbolsWithNM($image, $offset, $pclist, $symbols);
  if ($main::opt_interactive ||
      $main::opt_lines       ||
      $main::opt_files       ||
      $main::opt_list) {
    GetLineNumbers($image, $offset, $pclist, $symbols);
  }
}

sub GetLineNumbers {
  my $image = shift;
  my $offset = shift;
  my $pclist = shift;
  my $symbols = shift;

  # Make file with all PC values
  open(ADDRESSES, ">$main::tmpfile_sym") || error("$main::tmpfile_sym: $!\n");
  for (my $i = 0; $i <= $#{$pclist}; $i++) {
    printf ADDRESSES ("0x%x\n", $pclist->[$i] - $offset);
  }
  close(ADDRESSES);

  # Pass to addr2line
  open(SYMBOLS, "$ADDR2LINE -f -C -e $image <$main::tmpfile_sym |")
    || error("$ADDR2LINE: $!\n");
  my $count = 0;
  while (<SYMBOLS>) {
    chop;
    my $fullfunction = $_;

    $_ = <SYMBOLS>;
    chop;
    my $filelinenum = $_;
    if (!$main::opt_list) {
      $filelinenum =~ s|^.*/([^/]+:\d+)$|$1|;    # Remove directory name
    }

    my $pcstr = sprintf("0x%x", $pclist->[$count]);
    if (defined($symbols->{$pcstr})) {
      # Override just the line-number portion.  The function name portion
      # is less buggy when computed using nm instead of addr2line.
      $symbols->{$pcstr}->[1] = $filelinenum;
    } else {
      my $function = ShortFunctionName($fullfunction);
      $symbols->{$pcstr} = [$function, $filelinenum, $fullfunction];
    }
    $count++;
  }
  close(SYMBOLS);
}

# Alternate implementation
sub MapSymbolsWithNM {
  my $image = shift;
  my $offset = shift;
  my $pclist = shift;
  my $symbols = shift;

  # Get nm output sorted by increasing address
  my $symbol_table = GetProcedureBoundaries($image, ".");
  my @names = sort { $symbol_table->{$a}->[0] <=> $symbol_table->{$b}->[0] }
    keys(%{$symbol_table});

  if ($#names < 0) {
    # No symbols: just use address
    foreach my $pc (@{$pclist}) {
      my $pcstr = sprintf("0x%x", $pc);
      $symbols->{$pcstr} = [$pcstr, "?", $pcstr];
    }
    return;
  }

  # Sort addresses so we can do a join against nm output
  my $index = 0;
  my $fullname = $names[0];
  my $name = ShortFunctionName($fullname);
  foreach my $pc (sort { $a <=> $b } @{$pclist}) {
    # Adjust for mapped offset
    my $mpc = $pc - $offset;
    while (($index < $#names) && ($mpc >= $symbol_table->{$fullname}->[1])){
      $index++;
      $fullname = $names[$index];
      $name = ShortFunctionName($fullname);
    }
    my $pcstr = sprintf("0x%x", $pc);
    $symbols->{$pcstr} = [$name, "?", $fullname];
  }
}

sub ShortFunctionName {
  my $function = shift;
  while ($function =~ s/\([^()]*\)//g) { }   # Remove argument types
  while ($function =~ s/<[^<>]*>//g)  { }    # Remove template arguments
  $function =~ s/^.*\s+(\w+::)/$1/;          # Remove leading type
  return $function;
}

##### Miscellaneous #####

sub cleanup {
  unlink($main::tmpfile_sym);
  for (my $i = 0; $i < $main::next_tmpfile; $i++) {
    unlink(PsTempName($i));
  }
  # We leave any collected profiles in $HOME/pprof in case the user wants
  # to look at them later.  We print a message informing them of this.
  if (defined($main::collected_profile)) {
    print STDERR "Dynamically gathered profile is in $main::collected_profile\n";
    print STDERR "If you want to investigate this profile further, you can do:\n";
    print STDERR "\n";
    print STDERR "  pprof \\\n";
    print STDERR "    $prog \\\n";
    print STDERR "    $main::collected_profile\n";
    print STDERR "\n";
  }
}

sub sighandler {
  cleanup();
  exit(1);
}

sub error {
  my $msg = shift;
  print STDERR $msg;
  cleanup();
  exit(1);
}

# Return a list of all routines that match $regexp.
# For each routine, the following list is returned:
#       $result->[i]->[0]       Routine name
#       $result->[i]->[1]       Start address
#       $result->[i]->[2]       Finish address
#       $result->[i]->[3]       Image file name (program or shared library)
#       $result->[i]->[4]       Offset for image in address space
sub GetMatchingRoutines {
}


# Gets the procedure boundaries for all routines in "$image" whose names
# match "$regexp" and returns them in a hashtable mapping from procedure
# name to a two-element vector of [start address, end address]
sub GetProcedureBoundaries {
  my $image = shift;
  my $regexp = shift;

  my $symbol_table = {};
  open(NM, "$NM -C -n $image |") || error("$NM: $!\n");
  my $last_start = "0x0";
  my $routine = "";
  while (<NM>) {
    if (m/^([0-9a-f]+) . (..*)/) {
      my $start_val = $1;
      my $this_routine = $2;
      if (defined($routine) && $routine =~ m/$regexp/) {
        $symbol_table->{$routine} = [hex($last_start), hex($start_val)];
      }
      $last_start = $start_val;
      $routine = $this_routine;
    }
  }
  close(NM);

  return $symbol_table;
}
